---
id: prd-v1.0
type: document
subtype: product-requirements
lifecycle: active
status: ready
title: 'templ.js v1.0 - Product Requirements Document'
---

**Status**: Draft  
**Date**: February 2026  
**Owner**: Development Team  
**Target Release**: 8 weeks from approval

---

## Executive Summary

**templ.js** is a TypeScript-native meta-templating system that transforms structured data (JSON, YAML, TOML, XML) into formatted text using **templ** syntax (Handlebars-inspired for web familiarity) embedded in target output formats (Markdown, HTML, JSON, YAML, TOML, XML).

This PRD defines the v1.0 release, a ground-up TypeScript implementation with:

- **Chevrotain-based parser** (500k weekly npm downloads, SAP-backed)
- **Volar language server** (full IDE support: completion, hover, diagnostics)
- **Browser compatibility** (<100KB ESM bundle)
- **pnpm + Nx monorepo** (efficient builds, atomic releases)
- **90%+ test coverage** (800+ tests with comprehensive coverage)
- **Input/output validation** as first-class template feature
- **Whitespace control** syntax (strip, preserve modes like Handlebars, etc.)

### Success Criteria

1. **Performance**: <5ms parse time for 4KB templates
2. **Reliability**: 95%+ test coverage with zero known bugs
3. **Adoption**: 1,000+ npm downloads in first month
4. **Developer Experience**: <5 minutes from install to first render

---

## Goals and Non-Goals

### Goals

1. **Full IDE Support**: Syntax highlighting, diagnostics, completion, hover, go-to-definition in VS Code
2. **Browser Compatibility**: Run in browser environments (Netlify, Cloudflare Workers)
3. **Performance**: <5ms parse time, <20ms render time for 4KB templates
4. **Maintainability**: Single-language stack (TypeScript only)
5. **Extensibility**: Plugin API for custom functions and filters

### Language & Format Support

**Officially Supported Output Formats (v1.0)**:

- Markdown
- HTML
- JSON
- YAML
- TOML
- XML

(Additional formats can be supported via plugin API in future versions)

**Syntax Basis**: Handlebars-inspired (for web developer familiarity and ecosystem alignment)

### Non-Goals

1. **Multi-Editor Support**: v1.0 focuses on VS Code (other editors in v2.0)
2. **Visual Template Builder**: v1.0 is text-based (GUI may be considered in future)
3. **Real-Time Collaboration**: No operational transform for shared editing

---

## User Stories

### Primary Personas

#### 1. Data Engineer (Kai)

**Context**: Generates weekly reports from JSON analytics data  
**Pain Point**: Current tools lack type checking, produce brittle templates

**User Stories**:

- As Data Engineer, I want **autocomplete for data fields** so I don't misspell variable names
- As Data Engineer, I want **instant error feedback** so I catch bugs before running pipelines
- As Data Engineer, I want **to use templates in Node.js scripts** so I can automate report generation

#### 2. Technical Writer (Alex)

**Context**: Maintains documentation with examples from code repositories  
**Pain Point**: Manual updates break documentation when code changes

**User Stories**:

- As Technical Writer, I want **to embed code snippets from JSON** so docs stay in sync with source
- As Technical Writer, I want **Markdown preview** so I see rendered output while editing
- As Technical Writer, I want **conditional sections** so I maintain single docs for multiple products

#### 3. Frontend Developer (Jordan)

**Context**: Generates HTML emails from user activity data  
**Pain Point**: String concatenation is error-prone, no XSS protection

**User Stories**:

- As Frontend Developer, I want **HTML auto-escaping** so I don't accidentally inject XSS vulnerabilities
- As Frontend Developer, I want **to use templates in browser** so I can preview emails client-side
- As Frontend Developer, I want **to loop over arrays** so I can generate dynamic lists

---

## Functional Requirements

### FR-1: Core Parser (Chevrotain)

#### FR-1.1: Tokenization

- **Input**: Template string with configurable delimiters
- **Output**: Token stream with position metadata
- **Performance**: <1ms for 4KB template
- **Supported Tokens**:
  - `{{#if condition}}...{{/if}}` - Control blocks (if, for, etc.)
  - `{{variable}}` - Variable insertion
  - `{{!-- comment --}}` - Ignored content
  - **text** - Raw pass-through content
- **Whitespace Control**:
  - `{{~expression}}` - Strip whitespace before
  - `{{expression~}}` - Strip whitespace after
  - `{{-expression-}}` - Strip both sides

#### FR-1.2: Parsing

- **Input**: Token stream
- **Output**: Abstract Syntax Tree (AST)
- **Error Recovery**: Continue parsing after syntax errors (report all issues)
- **Performance**: <5ms for 4KB template
- **AST Structure**:

  ```typescript
  interface TemplateNode {
    type: 'text' | 'expression' | 'if' | 'for' | 'let';
    position: { line: number; column: number };
    children?: TemplateNode[];
  }
  ```

  **Node Types**:
  - `text`: Raw content (pass-through)
  - `expression`: Variable/filter: `{{ variable }}`
  - `if`: Conditional block: `{{#if cond}}...{{/if}}`
  - `for`: Loop block: `{{#for item in items}}...{{/for}}`
  - `let`: Scoped variable: `{{#let x = value}}...{{/let}}`

#### FR-1.3: Configurable Delimiters

- **Default**: `{{` and `}}`
- **Custom Example**:

  ```typescript
  parse(template, {
    expression_start: '<<:',
    expression_end: ':>>',
  });
  ```

- **Use Case**: Avoid conflicts with output format syntax or nested templates

### FR-2: Renderer & Validation

#### FR-2.1: Template Execution

- **Input**: AST + data object + optional schema
- **Output**: Rendered string
- **Performance**: <20ms for 4KB template with 100 iterations
- **Context Management**: Block-scoped variables (lexical scoping for control structures)

#### FR-2.1a: Input/Output Validation

- **Optional First-Class Feature**: Schemas can be embedded in templates
- **Input Validation**: Validate input data against JSON Schema before rendering
- **Output Validation**: Validate rendered output against schema or format-specific rules
- **Error Handling**: Detailed validation errors with path and value information
- **Integration**: Seamless with CLI via `--validate-input` and `--validate-output` flags

**Example Embedded Schema**:

```templ
{{! @schema input: {"type": "object", "required": ["name", "email"]} }}
{{! @schema output: {"type": "object", "required": ["html"]} }}
```

#### FR-2.2: Query Language

- **Dot Notation**: `user.profile.name`
- **Array Access**: `users[0].email`
- **Filters**: `{{ price | currency }}` (pipe syntax)
- **Built-in Functions**: Standard set of type-specific transformations

##### Built-in Functions by Category

###### **String Functions**

- `upper(str)` - Convert to uppercase
- `lower(str)` - Convert to lowercase
- `capitalize(str)` - Capitalize first letter
- `trim(str)` - Remove leading/trailing whitespace
- `ltrim(str)` - Remove leading whitespace
- `rtrim(str)` - Remove trailing whitespace
- `replace(str, search, replace)` - Replace all occurrences
- `slice(str, start, end)` - Extract substring
- `split(str, delimiter)` - Split into array
- `join(arr, delimiter)` - Join array into string
- `startsWith(str, prefix)` - Check prefix
- `endsWith(str, suffix)` - Check suffix
- `includes(str, substring)` - Check substring
- `indexOf(str, substring)` - Find position
- `padStart(str, length, char)` - Pad left
- `padEnd(str, length, char)` - Pad right
- `repeat(str, count)` - Repeat string
- `reverse(str)` - Reverse string
- `escape(str)` - HTML escape (default for safety)
- `default(val, fallback)` - Null coalescing

###### **Number Functions** (int/float)

- `round(num, decimals)` - Round to decimals
- `floor(num)` - Round down
- `ceil(num)` - Round up
- `abs(num)` - Absolute value
- `min(num1, num2, ...)` - Minimum value
- `max(num1, num2, ...)` - Maximum value
- `clamp(num, min, max)` - Constrain to range
- `sqrt(num)` - Square root
- `pow(num, exponent)` - Power function
- `log(num, base)` - Logarithm
- `exp(num)` - Exponential (e^x)
- `sin(num)`, `cos(num)`, `tan(num)` - Trigonometric
- `sum(arr)` - Sum array of numbers
- `avg(arr)` - Average of array
- `product(arr)` - Multiply array elements

###### **Datetime Functions**

- `now()` - Current ISO 8601 timestamp
- `format(date, pattern)` - Format date (e.g., `YYYY-MM-DD`)
- `parse(str, pattern)` - Parse date string
- `addDays(date, days)` - Add/subtract days
- `addHours(date, hours)` - Add/subtract hours
- `addMinutes(date, minutes)` - Add/subtract minutes
- `getYear(date)` - Extract year
- `getMonth(date)` - Extract month (1-12)
- `getDay(date)` - Extract day of month
- `getHour(date)` - Extract hour
- `timezone(date, tz)` - Convert timezone
- `timestamp(date)` - Unix timestamp in ms

###### **List/Array Functions**

- `length(arr)` - Array length
- `first(arr)` - First element
- `last(arr)` - Last element
- `nth(arr, index)` - Element at index
- `reverse(arr)` - Reverse array
- `sort(arr, key)` - Sort array (by key for objects)
- `unique(arr, key)` - Remove duplicates
- `flatten(arr, depth)` - Flatten nested arrays
- `slice(arr, start, end)` - Extract subarray
- `concat(arr1, arr2, ...)` - Concatenate arrays
- `join(arr, delimiter)` - Join as string
- `filter(arr, condition)` - Filter by condition
- `map(arr, transform)` - Transform each element
- `reduce(arr, accumulator, initial)` - Reduce array to single value
- `find(arr, condition)` - Find first match
- `includes(arr, value)` - Check membership
- `indexOf(arr, value)` - Find index

###### **Dictionary/Object Functions**

- `keys(obj)` - Array of keys
- `values(obj)` - Array of values
- `entries(obj)` - Array of [key, value] pairs
- `has(obj, key)` - Check key existence
- `get(obj, key, default)` - Get with fallback
- `merge(obj1, obj2, ...)` - Shallow merge
- `pick(obj, keys)` - Select specific keys
- `omit(obj, keys)` - Exclude specific keys
- `length(obj)` - Number of keys

##### Function Usage Examples

```templ
{# String transformations #}
{{ user.name | upper }}
{{ email | trim | lower }}
{{ date | format('YYYY-MM-DD') }}

{# Numeric calculations #}
{{ price | round(2) }}
{{ temperatures | avg }}
{{ values | sum }}

{# List operations #}
{{ items | length }}
{{ items | sort('name') | map('title') | join(', ') }}
{{ numbers | filter('> 10') | sum }}

{# Conditional defaults #}
{{ user.bio | default('No bio provided') }}
{{ config.timeout | default(30) | clamp(1, 60) }}

{# Chained transformations #}
{{ csv_data | split(',') | map(trim) | join('; ') }}
{{ log_entries | filter('level == "ERROR"') | length }}
```

#### FR-2.3: Control Structures & Scoping

```templ
{{#if user.is_admin}}Admin Dashboard{{/if}}
{{#for item in items}}{{item.name}}{{/for}}
{{#let local_var = "value"}}Scoped {{local_var}}{{/let}}
```

**Scoping Policy**:

- Each control block (`#if`, `#for`, `#let`, etc.) creates a new lexical scope
- Inner scopes inherit parent variables (lexical closure)
- Variables assigned in inner scope don't affect parent
- Block parameters shadow parent variables within the block
- Useful for avoiding variable name collisions in nested loops

### FR-3: VS Code Extension (Volar)

#### FR-3.1: Syntax Highlighting

- **File Extensions**: `.tmpl`, `.template`, and language-specific variations (`.md.tmpl`, `.html.tmpl`, `.json.tmpl`, `.yaml.tmpl`, `.toml.tmpl`, `.xml.tmpl`)
- **Semantic Highlighting**: Differentiate base format vs. templ syntax
- **Theme Support**: Respect VS Code color themes
- **Format Awareness**: Enable format-specific validation and formatting based on extension

#### FR-3.2: Diagnostics

- **Syntax Errors**: Unclosed tags, invalid delimiters
- **Semantic Errors**: Undefined variables, type mismatches, schema validation failures
- **Base Format Errors**: Delegate to VS Code language servers (JSON, Markdown, HTML, YAML, TOML, XML)
- **Validation Errors**: Input/output schema violations with detailed paths
- **Real-Time**: <200ms from file save to error display

#### FR-3.3: IntelliSense

- **Completion**: Variable names from schema, built-in filters
- **Hover**: Show variable types, function signatures
- **Go-to-Definition**: Jump to schema field definitions
- **Parameter Hints**: Show function argument types

#### FR-3.4: Formatting

- **Base Format**: Delegate to VS Code formatters (Prettier, etc.)
- **Template Syntax**: Preserve indentation, align delimiters
- **Configuration**: Respect `.editorconfig`, `.prettierrc`, etc.

### FR-4: CLI Tool

#### FR-4.1: Commands

```bash
templjs render --input data.json --template output.md.tmpl --output result.md
cat data.json | templjs render -t output.md.tmpl > result.md  # stdin/stdout pipes
templjs validate --template report.md.tmpl --input data.json [--schema input-schema.json]
templjs validate --template report.md.tmpl --output output.md [--schema output-schema.json]
templjs init --format markdown  # Generate sample template
```

**Validation Modes**:

- **Input validation**: Enabled by default if schema provided (via template `@schema` or `--schema`); disable with `--no-validate-input`
- **Output validation**: Enabled by default if schema provided; disable with `--no-validate-output`
- Schema can be embedded in template comments or provided via CLI `--schema` flag

#### FR-4.2: Input Formats

- **JSON**: Direct parsing
- **YAML**: Requires `js-yaml` dependency
- **TOML**: Requires `@iarna/toml` dependency
- **XML**: Requires `xml2js` dependency (converts to object structure)
- **Stdin**: Auto-detect format or specify with `--input-format=json|yaml|toml|xml`

#### FR-4.3: Output Modes

- **File**: `--output result.md`
- **Stdout**: Default if `--output` omitted
- **Watch Mode**: `--watch` re-renders on input changes

### FR-5: Testing Infrastructure

#### FR-5.1: Test Coverage

- **Overall**: 90%+
- **Core Parser**: 95%+
- **Renderer**: 95%+
- **VS Code Extension**: 80%+

#### FR-5.2: Test Categories

- **Unit Tests**: 600+ tests (lexer, parser, renderer functions)
- **Integration Tests**: 150+ tests (end-to-end workflows)
- **Extension Tests**: 50+ tests (VS Code API interactions)

#### FR-5.3: CI/CD & Quality Gates

**Linting & Code Quality**:

- **TypeScript/JavaScript**: ESLint + Prettier
- **Shell Scripts**: ShellCheck for POSIX compliance
- **Markdown**: markdownlint with consistent style
- **YAML**: yamllint for syntax and formatting
- **JSON**: Built-in JSON validator
- **Pre-commit hooks**: Enforce checks before commits (Husky + lint-staged)

**Security**:

- **Pre-Commit Detection**: `detect-secrets` scans staged files (fast, pattern-based: AWS keys, API tokens, .env patterns) with minimal false positives
- **Periodic Deep Scans**: TruffleHog runs on schedule (weekly) for comprehensive entropy-based detection across commit history
- **Dependency Audit**: npm audit on publish

**Testing & Coverage**:

- **GitHub Actions**: Run tests on push, PR
- **Coverage Reporting**: Codecov integration with merge gates (no drops below 95%)
- **Performance Benchmarks**: ASV (Airspeed Velocity) for regression detection on every PR

**Performance Targets**:

- Tests: <30 seconds (350+ tests)
- Linting: <10 seconds (all checks)
- Pre-commit detect-secrets scan: <2 seconds (staged files only)
- Build: <2 minutes (full pipeline)
- Full PR checks: <5 minutes (on main, without periodic TruffleHog)
- Periodic TruffleHog scan: <5 minutes (runs weekly, not blocking PR)

---

## Non-Functional Requirements

### NFR-1: Performance

| Metric                   | Target                 | Measured With              |
| ------------------------ | ---------------------- | -------------------------- |
| **Tokenization**         | <1ms (4KB)             | ASV benchmarks             |
| **Parsing**              | <5ms (4KB)             | ASV benchmarks             |
| **Rendering**            | <20ms (100 iterations) | ASV benchmarks             |
| **Extension Activation** | <500ms                 | VS Code startup trace      |
| **Diagnostic Latency**   | <200ms                 | File save to error display |

### NFR-2: Reliability

- **Zero Known Bugs**: All GitHub issues and backlog bugs resolved before v1.0
- **95%+ Test Coverage**: Core library fully tested
- **Error Recovery**: Parser continues after syntax errors
- **Backward Compatibility**: Semantic versioning, deprecation warnings

### NFR-3: Usability

- **Time-to-First-Render**: <5 minutes from `npm install` to output
- **Error Messages**: Actionable, reference exact line/column
- **Documentation**: Getting started guide, API reference, examples
- **Examples**: 10+ real-world templates (reports, emails, docs)

### NFR-4: Maintainability

- **Single Language**: TypeScript only (no Python, Go, Rust)
- **Code Quality**: ESLint + Prettier, 100% type-safe
- **Architecture Docs**: ADRs for all major decisions
- **CI/CD Quality**:
  - Lint all source technologies: TypeScript, JavaScript, Bash, Markdown, YAML, JSON
  - Secret scanning on every commit (detect .env leaks, API keys, credentials)
  - Coverage gates: Block merge if coverage drops below threshold
  - Performance regression detection: Benchmark comparisons on every PR

### NFR-5: Contributing

- **Time-to-First-Commit**: <15 minutes (install deps, setup local dev, run tests)
- **Clear Contribution Guide**: Setup instructions, code style, PR process
- **Low-Friction Onboarding**: Example first-time PRs marked "good-first-issue"
- **Fast CI Feedback**: <2 min full PR checks on GitHub Actions
- **Responsive Reviews**: <24 hours median PR response time

---

## Success Metrics

### Launch Metrics (1 Month Post-Release)

**Realistic Targets** (positioning templ.js as niche productivity tool, not mainstream):

- **npm Downloads**: 200-500 for `@templjs/core` (modest but engaged audience)
- **VS Code Installs**: 100-300 for `vscode-templjs`
- **GitHub Stars**: 30-50 on repo (quality over quantity)
- **Documentation Views**: 1,000-2,000 page views from developers considering tool
- **Community Discord/Discussions**: 10-20 active members

### Engagement Metrics (3 Months Post-Release)

- **Active Users**: 50-100 weekly active npm downloads (steady, engaged base)
- **Community Contributions**: 2-3 merged PRs from external contributors
- **Issue Resolution**: <72 hours median response time for bugs
- **Bug Reports**: <5 open critical bugs, <15 open non-critical
- **Feature Requests**: 5-10 community feature suggestions

### Technical Metrics (Ongoing)

- **Build Time**: <3 minutes full CI pipeline
- **Test Execution**: <30 seconds full suite (350+ tests)
- **Bundle Size**: <100KB for `@templjs/core` (minified + gzipped)
- **Performance Regression**: 0 benchmarks slower than v1.0 baseline
- **Documentation Completeness**: 100% of public API documented with examples

---

## Timeline and Milestones

### Phase 1: Infrastructure (Weeks 1-2)

- ✅ Create GitHub organization: `templjs`
- ✅ Initialize monorepo with pnpm + Nx
- ✅ Setup CI/CD (GitHub Actions, Codecov)
- ✅ Configure pre-commit hooks (ESLint, Prettier)
- **Milestone**: `v0.1.0` - Empty packages published to npm

### Phase 2: Core Library (Weeks 3-4)

- ✅ Implement Chevrotain lexer (200+ tests)
- ✅ Implement Chevrotain parser (300+ tests)
- ✅ Implement renderer (200+ tests)
- ✅ Implement query engine (100+ tests)
- **Milestone**: `v0.2.0` - Core library functional

### Phase 3: VS Code Extension (Weeks 5-6)

- ✅ Build Volar language server plugin
- ✅ Implement diagnostics (50+ tests)
- ✅ Implement IntelliSense (30+ tests)
- ✅ Implement syntax highlighting
- **Milestone**: `v0.3.0` - Extension functional

### Phase 4: CLI Tool (Week 7)

- ✅ Implement `render`, `validate`, `init` commands
- ✅ Add watch mode
- ✅ Write CLI tests (50+ tests)
- **Milestone**: `v0.4.0` - CLI functional

### Phase 5: Documentation and Release (Week 8)

- ✅ Write getting started guide
- ✅ Write API reference
- ✅ Create 10+ example templates
- ✅ Record demo video
- ✅ Publish v1.0 to npm + VS Code Marketplace
- **Milestone**: `v1.0.0` - Public release

---

## Risks and Mitigations

### Risk 1: Chevrotain Performance

**Likelihood**: Medium | **Impact**: High  
**Mitigation**:

- Benchmark early with 10KB+ templates
- Optimize parser rules (left-recursion elimination)
- Fallback: Switch to Nearley if <50ms parse time unmet

### Risk 2: Volar API Instability

**Likelihood**: Low | **Impact**: Medium  
**Mitigation**:

- Pin Volar version in package.json
- Monitor Volar release notes for breaking changes
- Fallback: Implement minimal LSP server without Volar

### Risk 3: Community Adoption

**Likelihood**: Medium | **Impact**: Medium  
**Mitigation**:

- Publish to npm, VS Code Marketplace with SEO-optimized descriptions
- Post on Hacker News, Reddit (/r/typescript, /r/vscode)
- Create comparison blog post (templ.js vs. [Handlebars, Mustache, XSLT, Jinja2])

### Risk 4: Test Migration Effort

**Likelihood**: Low | **Impact**: Low  
**Mitigation**:

- Port tests incrementally (100 tests/day)
- Use Vitest's Jest-compatible API for minimal changes
- Automate with regex find/replace (pytest → vitest)

---

## Dependencies

### Internal Dependencies

- **@templjs/core**: Required by CLI, Volar plugin, VS Code extension
- **@templjs/volar**: Required by VS Code extension

### External Dependencies

| Package        | Version | Purpose                   |
| -------------- | ------- | ------------------------- |
| **chevrotain** | ^11.0   | Parser combinator         |
| **volar**      | ^2.0    | Language server framework |
| **vitest**     | ^1.0    | Testing framework         |
| **typescript** | ^5.0    | Type system               |
| **commander**  | ^11.0   | CLI framework             |

---

## Open Questions

1. **Q: Support for custom functions/filters in v1.0?**  
   **A**: Yes, via plugin API. Example: `registerFilter('currency', (value) => ...)`

2. **Q: Schema validation required for v1.0?**  
   **A**: Optional but enabled by default if schemas provided. Users can explicitly disable with `--no-validate-input` or `--no-validate-output`.

3. **Q: Support TOML/XML in v1.0?**  
   **A**: Yes (added after user feedback). Both officially supported input formats.

---

## Appendix

### A. Design Rationale: Syntax Foundation

#### Why Handlebars-Inspired?

templ.js uses Handlebars-inspired syntax for several reasons:

1. **Web Developer Ecosystem**: Handlebars is widely used in Express.js, JavaScript tooling, and web frameworks
2. **Familiarity**: Developers coming from JavaScript/Node.js recognize the syntax
3. **Simplicity**: Handlebars philosophy aligns with our goal of lightweight templates
4. **Extensibility**: Handlebars' helper system maps naturally to our filter/function API

#### Architecture: Designed for Future Syntax Flexibility

While v1.0 commits to Handlebars-inspired syntax, the architecture intentionally separates concerns to support alternative syntax themes in future versions:

- **Tokenization**: Configurable delimiters already support custom start/end tokens
- **Parsing**: Parser logic is independent of lexer, allowing alternative token sequences
- **Rendering**: Renderer interprets AST, not raw tokens—same renderer works for any syntax
- **Future**: Supporting Jinja2-style delimiters (`{% %}`), Liquid syntax, or other templates would require only alternate lexer/parser implementations, no renderer changes

This design enables v1.1+ to offer "syntax themes" without breaking existing templates or renderer logic. See [[ADR-007 Syntax Extensibility]] for architectural details.

### B. References

- [ADR-001: Language Migration](./adr/001-language-migration.md)
- [ADR-002: Parser Selection](./adr/002-parser-selection.md)
- [ADR-003: VS Code Architecture](./adr/003-vscode-architecture.md)
- [ADR-004: Branding](./adr/004-branding.md)
- [ADR-005: Monorepo Structure](./adr/005-monorepo.md)
- [ADR-006: Testing Strategy](./adr/006-testing.md)
- [ADR-007: Syntax Extensibility](./adr/007-syntax-extensibility.md)
